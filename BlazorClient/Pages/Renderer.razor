@using Blazor.Extensions;
@using Blazor.Extensions.Canvas;
@using Blazor.Extensions.Canvas.Canvas2D;
@using RoverSim.Rendering;

<div id=render>
    <BECanvas Width="@_canvasWidth" Height="@_canvasHeight" @ref="_canvasReference"></BECanvas>
</div>
<div id=controls>
    <div id=stats>
        <div id=moves-left>Moves Left: @_stats.MovesLeft</div>
        <div id=power>Power: @_stats.Power</div>
        <div id=hopper-count>Hopper Count: @_stats.SamplesCollected</div>
        <div id=pending-count>Processed Count: @_stats.SamplesProcessed</div>
        <div id=sample-transmitted-count>Transmitted: @_stats.SamplesTransmitted</div>
        <div id=moves>Actual Moves: @_stats.MoveCount</div>
        <div id=move-calls>Move Calls: @_stats.MoveCallCount</div>
        <div id=power-calls>Power Calls: @_stats.CollectPowerCallCount</div>
        <div id=sample-calls>Sample Calls: @_stats.CollectSampleCallCount</div>
        <div id=process-calls>Process Calls: @_stats.ProcessSamplesCallCount</div>
        <div id=transmit-calls>Transmit Calls: @_stats.TransmitCallCount</div>
    </div>
    <div disabled=@_isDemoRunning class="button-link progressing"><button disabled=@_isDemoRunning @onclick=StartDemo>Start</button></div>
</div>

@code {
        // Target 4k UHD resolution at the largest
    private const Int32 MaxCanvasWidth = 0xF00;
    private const Int32 MaxCanvasHeight = 0xF00;

    private readonly String[] _fillStyles = new String[]
    {
        "black",
        "red",
        "lightgrey",
        "brown",
        "darkgrey",
        "lightgoldenrodyellow"
    };

    private RoverStats _stats;
    private Boolean _isDemoRunning = true;

    private Int32 _canvasWidth;
    private Int32 _canvasHeight;
    private Int32 _tileSize;
    private Double _roverSize;

    private Queue<Update?> _updates = new Queue<Update?>(2);
    private VisibleState _visibleState;
    private Boolean _rendering;
    private Canvas2DContext _context;
    protected BECanvasComponent _canvasReference;

    [Parameter]
    public SimulationParameters Parameters { get; set; }

    [Parameter]
    public IAi Ai { get; set; }

    [Parameter]
    public ProtoLevel ProtoLevel { get; set; }

    protected override void OnParametersSet()
    {
        if (Parameters == null || Ai == null || ProtoLevel == null)
            throw new InvalidOperationException("All component parameters must be set.");

        _visibleState = VisibleState.GenerateBlank(Parameters);
        _isDemoRunning = false;
        SetDimensions();
    }

    private void SetDimensions()
    {
        const Double roverScale = .64;
        Int32 widthFactor = MaxCanvasWidth / _visibleState.Width;
        Int32 heightFactor = MaxCanvasHeight / _visibleState.Height;
        Int32 tileSize = Math.Max(Math.Min(widthFactor, heightFactor), 1);

        _canvasWidth = _visibleState.Width * tileSize;
        _canvasHeight = _visibleState.Height * tileSize;
        _tileSize = tileSize;
        _roverSize = tileSize * roverScale;
    }

    private Task StartDemo()
    {
        Level level = ProtoLevel.Generate();
        if (level == null)
        {
            // This seed doesn't produce a valid level.
            // TODO: Show an error message.
            return Task.CompletedTask;
        }

        SimulationParameters parameters = Parameters;
        _visibleState = VisibleState.GenerateBlank(parameters);
        _isDemoRunning = true;

        Rover rover = new Rover(level, parameters);
        _stats = RoverStats.Create(parameters);


        IAi ai = Ai.CloneFresh();
        var actionEnumerator = ai.Simulate(rover.Accessor).GetEnumerator();

        return Task.Run(async () =>
        {
            // We use null to indicate that the level has been reset.
            _updates.Enqueue(null);
            _updates.Enqueue(new Update(terrain: rover.Adjacent));
            base.StateHasChanged();
            await Task.Delay(100);

            while (actionEnumerator.MoveNext() && rover.Perform(actionEnumerator.Current, out Update update))
            {
                _updates.Enqueue(update);
                _stats = _stats.Add(actionEnumerator.Current, update);
                base.StateHasChanged();
                Int32 delay = actionEnumerator.Current.Instruction switch
                {
                    Instruction.Move => 75,
                    Instruction.CollectSample => 50,
                    _ => 0
                };
                Console.WriteLine("Delaying " + delay + "ms");
                if (delay != 0)
                    await Task.Delay(delay);
            }

            _isDemoRunning = false;
            actionEnumerator.Dispose();
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _context ??= await _canvasReference.CreateCanvas2DAsync();

        if (_visibleState == null || _updates.Count == 0 || _rendering)
            return;

        // Since Blazor is single threaded, we don't need to worry about concurrent modification
        _rendering = true;
        while (_updates.Count > 0)
        {
            Update? update = _updates.Dequeue();
            if (!update.HasValue)
                await Clear();
            else if (_visibleState.Apply(update.Value))
                await RenderUpdate();
        }
        _rendering = false;
    }

    private async Task Clear()
    {
        await _context.SetFillStyleAsync(_fillStyles[5]);
        await _context.FillRectAsync(0, 0, _canvasReference.Width, _canvasReference.Height);
    }

    private async Task RenderUpdate()
    {
        await _context.BeginBatchAsync();
        for (Int32 i = 0; i < AdjacentTerrain.Count; i++)
        {
            Direction direction = Direction.FromInt32(i);
            CoordinatePair coords = _visibleState.RoverPosition + direction;
            if (coords.IsNegative)
                continue;

            TerrainType terrain = _visibleState[coords.X, coords.Y];

            String style = _fillStyles[(Int32)terrain];
            Int32 topLeftX = _tileSize * coords.X;
            Int32 topLeftY = _tileSize * coords.Y;
            await _context.SetFillStyleAsync(style);
            await _context.FillRectAsync(topLeftX, topLeftY, _tileSize, _tileSize);
        }

        await RenderRover();
        await _context.EndBatchAsync();
    }

    private async Task RenderRover()
    {
        Double roverPadding = (_tileSize - _roverSize) / 2;

        Double topLeftX = _tileSize * _visibleState.RoverPosition.X + roverPadding;
        Double topLeftY = _tileSize * _visibleState.RoverPosition.Y + roverPadding;

        await _context.SetFillStyleAsync("lightgreen");
        await _context.FillRectAsync(topLeftX, topLeftY, _roverSize, _roverSize);
    }
}
